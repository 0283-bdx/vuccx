<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>YUYUEçš„ä¸ªäººç½‘ç•Œ</title>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
body {
max-width: 800px;
margin: 2rem auto;
padding: 1rem;
font-family: system-ui, sans-serif;
line-height: 1.6;
color: #fff;
background: #000;
overflow-x: hidden;
position: relative;
}

.starfield {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #0f0f1a 100%);
}

.star {
  position: absolute;
  background: white;
  border-radius: 50%;
  opacity: 0.8;
  animation: twinkle 3s infinite;
  transition: opacity 0.3s ease;
}

@keyframes twinkle {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}

.black-hole {
  position: absolute;
  border-radius: 50%;
  background: #000;
  box-shadow: 0 0 20px 5px rgba(75, 0, 130, 0.8), 
              0 0 40px 10px rgba(148, 0, 211, 0.5),
              0 0 60px 15px rgba(75, 0, 130, 0.3);
  z-index: 1;
  /* æ·»åŠ widthå’Œheightçš„è¿‡æ¸¡æ•ˆæœ */
  transition: width 0.5s ease-out, height 0.5s ease-out, transform 0.3s ease-out, left 0.3s ease-out, top 0.3s ease-out;
  animation: rotate 5s infinite linear;
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

#content {
  background: rgba(0, 0, 0, 0.7);
  padding: 2rem;
  border-radius: 10px;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  z-index: 1;
}

pre { 
  background: rgba(255, 255, 255, 0.1); 
  padding: 1rem; 
  overflow-x: auto; 
  border-radius: 5px;
  color: #fff;
}

code { 
  background: rgba(255, 255, 255, 0.15); 
  padding: 0.2rem 0.4rem; 
  border-radius: 3px;
  color: #fff;
}

h1, h2, h3 { 
  margin-top: 2em; 
  color: #fff;
}

h1 {
  text-align: center;
  background: rgba(255, 255, 255, 0.1);
  padding: 1rem;
  border-radius: 10px;
  margin-bottom: 2rem;
}

.loading {
  text-align: center;
  opacity: 0.7;
}

.error {
  color: #ff6b6b;
  background: rgba(255, 107, 107, 0.1);
  padding: 1rem;
  border-radius: 5px;
  border: 1px solid rgba(255, 107, 107, 0.3);
}
</style>
</head>
<body>
<div class="starfield" id="starfield"></div>

<h1>ğŸ“˜ Markdown é¡µé¢</h1>
<div id="content" class="loading">æ­£åœ¨åŠ è½½å†…å®¹â€¦</div>

<script>
class StarField {
constructor() {
this.container = document.getElementById('starfield');
this.stars = [];
this.numStars = 400;
this.mouse = { x: 0, y: 0, lastX: 0, lastY: 0 };
this.animationId = null;
this.lastTime = 0;
this.mouseInPage = true; // æ·»åŠ é¼ æ ‡æ˜¯å¦åœ¨é¡µé¢å†…çš„æ ‡å¿—

    // é»‘æ´ç›¸å…³å±æ€§
    this.blackHole = null;
    this.blackHoleTimer = null;
    this.blackHoleActive = false;
    this.attractedStars = new Set();
    this.hoverStartTime = 0;
    this.consumedStarsCount = 0;
    // æ·»åŠ è®°å½•é»‘æ´åˆå§‹ä½ç½®çš„å˜é‡
    this.blackHoleOriginX = 0;
    this.blackHoleOriginY = 0;
    
    this.init();
    this.bindEvents();
    this.animate();
  }

  init() {
    this.container.innerHTML = '';
    this.stars = [];
    
    for (let i = 0; i < this.numStars; i++) {
      this.stars.push(this.createStar());
    }
  }

  createStar() {
    const star = document.createElement('div');
    star.className = 'star';
    
    const size = Math.random() * 3 + 1;
    star.style.width = size + 'px';
    star.style.height = size + 'px';
    
    const margin = 300;
    const x = Math.random() * (window.innerWidth + margin * 2) - margin;
    const y = Math.random() * (window.innerHeight + margin * 2) - margin;
    
    star.style.animationDelay = Math.random() * 3 + 's';
    
    this.container.appendChild(star);
    
    return {
      element: star,
      originalX: x,
      originalY: y,
      rotatedX: x,
      rotatedY: y,
      mouseOffsetX: 0,
      mouseOffsetY: 0,
      size: size,
      active: true,
      attracted: false
    };
  }

  bindEvents() {
    document.addEventListener('mousemove', (e) => {
      this.mouse.lastX = this.mouse.x;
      this.mouse.lastY = this.mouse.y;
      this.mouse.x = e.clientX;
      this.mouse.y = e.clientY;
      
      // æ£€æµ‹é»‘æ´æ˜¯å¦è·ç¦»åˆå§‹ä½ç½®è¿‡è¿œ
      if (this.blackHoleActive) {
        const distanceFromOrigin = Math.sqrt(
          Math.pow(this.mouse.x - this.blackHoleOriginX, 2) + 
          Math.pow(this.mouse.y - this.blackHoleOriginY, 2)
        );
        
        // å½“è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼ˆä¾‹å¦‚100åƒç´ ï¼‰æ—¶é‡ç½®é»‘æ´
        if (distanceFromOrigin > 20) {
          this.resetBlackHole();
        }
      }
      
      // ç¡®ä¿é¼ æ ‡åœ¨é¡µé¢å†…
      this.mouseInPage = true;
    });
    
    // æ·»åŠ é¼ æ ‡ç¦»å¼€é¡µé¢çš„äº‹ä»¶ç›‘å¬
    document.addEventListener('mouseleave', () => {
      this.mouseInPage = false;
      this.resetBlackHole();
    });

    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        this.handleResize();
      }, 250);
    });
  }

  handleResize() {
    const margin = 300;
    this.stars.forEach(star => {
      star.originalX = Math.random() * (window.innerWidth + margin * 2) - margin;
      star.originalY = Math.random() * (window.innerHeight + margin * 2) - margin;
      star.rotatedX = star.originalX;
      star.rotatedY = star.originalY;
      star.mouseOffsetX = 0;
      star.mouseOffsetY = 0;
    });
    this.resetBlackHole();
  }

  // åˆ›å»ºé»‘æ´ - ä¿®æ”¹ä¸ºæ¸è¿›å¼å¢é•¿
  createBlackHole() {
    if (this.blackHole) {
      this.container.removeChild(this.blackHole);
    }
    
    // è®°å½•é»‘æ´åˆ›å»ºæ—¶çš„ä½ç½®
    this.blackHoleOriginX = this.mouse.x;
    this.blackHoleOriginY = this.mouse.y;
    
    this.blackHole = document.createElement('div');
    this.blackHole.className = 'black-hole';
    
    // åˆå§‹å¤§å°
    const initialSize = 10;
    // ç›®æ ‡å¤§å°ï¼ˆåŸºäºå¸å¼•çš„æ˜Ÿæ˜Ÿæ•°é‡ï¼‰
    const targetSize = Math.max(20, Math.min(100, this.attractedStars.size * 5));
    
    this.blackHole.style.width = initialSize + 'px';
    this.blackHole.style.height = initialSize + 'px';
    this.blackHole.style.left = (this.mouse.x - initialSize/2) + 'px';
    this.blackHole.style.top = (this.mouse.y - initialSize/2) + 'px';
    
    this.container.appendChild(this.blackHole);
    
    // ä½¿ç”¨requestAnimationFrameå®ç°å¹³æ»‘çš„å¤§å°å¢é•¿
    let currentSize = initialSize;
    let lastTime = 0;
    
    const growBlackHole = (timestamp) => {
      if (!this.blackHole || !this.blackHoleActive) return;
      
      // æ§åˆ¶åŠ¨ç”»å¸§ç‡
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      if (deltaTime < 16) {
        requestAnimationFrame(growBlackHole);
        return;
      }
      lastTime = timestamp;
      
      // é€æ¸å¢åŠ å¤§å°
      if (currentSize < targetSize) {
        currentSize += Math.max(1, (targetSize - currentSize) * 0.05); // å¹³æ»‘è¿‡æ¸¡
        
        this.blackHole.style.width = currentSize + 'px';
        this.blackHole.style.height = currentSize + 'px';
        this.blackHole.style.left = (this.mouse.x - currentSize/2) + 'px';
        this.blackHole.style.top = (this.mouse.y - currentSize/2) + 'px';
        
        requestAnimationFrame(growBlackHole);
      }
    };
    
    this.blackHoleActive = true;
    this.consumedStarsCount = this.attractedStars.size;
    
    // éšè—è¢«å¸å¼•çš„æ˜Ÿæ˜Ÿ
    this.attractedStars.forEach(starIndex => {
      this.stars[starIndex].element.style.opacity = 0;
      this.stars[starIndex].active = false;
    });
    
    // å¯åŠ¨é»‘æ´å¢é•¿åŠ¨ç”»
    requestAnimationFrame(growBlackHole);
  }

  // æ›´æ–°é»‘æ´å¤§å° - ä½¿ç”¨æ¸è¿›å¼å¢é•¿
  updateBlackHoleSize() {
    if (!this.blackHole || !this.blackHoleActive) return;
    
    const newSize = Math.max(20, Math.min(300, this.consumedStarsCount * 5));
    // ä½¿ç”¨CSSè¿‡æ¸¡æ¥å¹³æ»‘å˜åŒ–å¤§å°
    this.blackHole.style.width = newSize + 'px';
    this.blackHole.style.height = newSize + 'px';
    this.blackHole.style.left = (this.mouse.x - newSize/2) + 'px';
    this.blackHole.style.top = (this.mouse.y - newSize/2) + 'px';
  }

  // é‡ç½®é»‘æ´çŠ¶æ€
  resetBlackHole() {
    clearTimeout(this.blackHoleTimer);
    this.hoverStartTime = 0;
    
    if (this.blackHoleActive) {
      if (this.blackHole) {
        this.container.removeChild(this.blackHole);
        this.blackHole = null;
      }
      
      // æ¢å¤æ‰€æœ‰æ˜Ÿæ˜Ÿ
      this.stars.forEach(star => {
        star.active = true;
        star.attracted = false;
        star.element.style.opacity = 0.8;
      });
      
      this.blackHoleActive = false;
      this.attractedStars.clear();
      this.consumedStarsCount = 0;
    }
  }

  animate = (currentTime) => {
    try {
      if (currentTime - this.lastTime < 16) {
        this.animationId = requestAnimationFrame(this.animate);
        return;
      }
      
      this.lastTime = currentTime;
      
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const rotation = currentTime * 0.0001;
      
      // ç»Ÿè®¡å½“å‰è¢«å¸å¼•çš„æ˜Ÿæ˜Ÿ
      this.attractedStars.clear();
      let attractedCount = 0;
      
      this.stars.forEach((star, index) => {
        if (!star.active) return;
        
        // è®¡ç®—æ—‹è½¬åçš„ä½ç½®
        const relativeX = star.originalX - centerX;
        const relativeY = star.originalY - centerY;
        star.rotatedX = centerX + (relativeX * Math.cos(rotation) - relativeY * Math.sin(rotation));
        star.rotatedY = centerY + (relativeX * Math.sin(rotation) + relativeY * Math.cos(rotation));

        // åªæœ‰å½“é¼ æ ‡åœ¨é¡µé¢å†…æ—¶æ‰åº”ç”¨é¼ æ ‡å¸å¼•æ•ˆæœ
        if (this.mouseInPage) {
          // è®¡ç®—ä¸é¼ æ ‡çš„è·ç¦»
          const dx = this.mouse.x - (star.rotatedX + star.mouseOffsetX);
          const dy = this.mouse.y - (star.rotatedY + star.mouseOffsetY);
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // é»‘æ´å¸å¼•èŒƒå›´
          const blackHoleRadius = this.blackHoleActive ? 
            parseInt(this.blackHole.style.width) / 2 + 100 : 0;
          
          if (this.blackHoleActive && distance < blackHoleRadius) {
            // é»‘æ´å¸å¼•æ•ˆæœ
            const force = (blackHoleRadius - distance) / blackHoleRadius;
            const pullX = dx * force * 0.2;
            const pullY = dy * force * 0.2;
            
            star.mouseOffsetX += pullX;
            star.mouseOffsetY += pullY;
            
            // æ£€æŸ¥æ˜¯å¦è¢«é»‘æ´åå™¬
            if (distance < parseInt(this.blackHole.style.width) / 2) {
              star.active = false;
              star.element.style.opacity = 0;
              this.consumedStarsCount++;
              this.updateBlackHoleSize();
            }
          } else if (distance < 150) {
            // æ™®é€šé¼ æ ‡å¸å¼•æ•ˆæœ
            const force = (150 - distance) / 150;
            const pullX = dx * force * 0.1;
            const pullY = dy * force * 0.1;
            
            star.mouseOffsetX += pullX;
            star.mouseOffsetY += pullY;
            
            // å¦‚æœæ˜Ÿæ˜Ÿè¢«å¸å¼•ï¼Œè®°å½•ä¸‹æ¥
            if (Math.abs(pullX) > 0.5 || Math.abs(pullY) > 0.5) {
              star.attracted = true;
              this.attractedStars.add(index);
              attractedCount++;
            }
          } else {
            // ç¼“æ…¢å›åˆ°åŸä½
            star.mouseOffsetX *= 0.98;
            star.mouseOffsetY *= 0.98;
            star.attracted = false;
          }
        } else {
          // é¼ æ ‡ä¸åœ¨é¡µé¢å†…ï¼Œæ‰€æœ‰æ˜Ÿæ˜Ÿç¼“æ…¢å›åˆ°åŸä½
          star.mouseOffsetX *= 0.98;
          star.mouseOffsetY *= 0.98;
          star.attracted = false;
        }

        // æœ€ç»ˆä½ç½®
        const finalX = star.rotatedX + star.mouseOffsetX;
        const finalY = star.rotatedY + star.mouseOffsetY;

        star.element.style.left = finalX + 'px';
        star.element.style.top = finalY + 'px';
      });
      
      // æ£€æµ‹æ˜¯å¦æ»¡è¶³é»‘æ´ç”Ÿæˆæ¡ä»¶ - åªåœ¨é¼ æ ‡åœ¨é¡µé¢å†…æ—¶æ£€æµ‹
      if (this.mouseInPage && !this.blackHoleActive && attractedCount >= 5) {
        if (this.hoverStartTime === 0) {
          this.hoverStartTime = currentTime;
        } else if (currentTime - this.hoverStartTime > 3000) { // 3ç§’åè§¦å‘
          this.createBlackHole();
        }
      } else if (!this.blackHoleActive) {
        this.hoverStartTime = 0;
      }
      
      // å¦‚æœé»‘æ´å­˜åœ¨ï¼Œæ›´æ–°ä½ç½® - åªåœ¨é¼ æ ‡åœ¨é¡µé¢å†…æ—¶æ›´æ–°
      if (this.mouseInPage && this.blackHoleActive && this.blackHole) {
        const size = parseInt(this.blackHole.style.width);
        this.blackHole.style.left = (this.mouse.x - size/2) + 'px';
        this.blackHole.style.top = (this.mouse.y - size/2) + 'px';
      }
      
      this.animationId = requestAnimationFrame(this.animate);
    } catch (error) {
      console.error('åŠ¨ç”»é”™è¯¯:', error);
      setTimeout(() => {
        this.animationId = requestAnimationFrame(this.animate);
      }, 1000);
    }
  }

  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
    this.resetBlackHole();
    this.container.innerHTML = '';
    this.stars = [];
  }
}

class ContentLoader {
  constructor() {
    this.contentEl = document.getElementById('content');
    this.loadContent();
  }

  async loadContent() {
    try {
      const response = await fetch('a01.md');
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const mdContent = await response.text();
      
      if (typeof marked === 'undefined') {
        throw new Error('Marked åº“æœªæ­£ç¡®åŠ è½½');
      }
      
      this.contentEl.innerHTML = marked.parse(mdContent);
      this.contentEl.classList.remove('loading');
      
    } catch (error) {
      console.error('å†…å®¹åŠ è½½å¤±è´¥:', error);
      this.showError(error);
    }
  }

  showError(error) {
    this.contentEl.classList.remove('loading');
    this.contentEl.classList.add('error');
    
    let errorMessage = 'âŒ æ— æ³•åŠ è½½å†…å®¹';
    
    if (error.message.includes('HTTP 404')) {
      errorMessage = 'âŒ æ‰¾ä¸åˆ° a01.md æ–‡ä»¶ï¼Œè¯·ç¡®è®¤æ–‡ä»¶è·¯å¾„æ­£ç¡®';
    } else if (error.message.includes('Marked')) {
      errorMessage = 'âŒ Markdown è§£æå™¨åŠ è½½å¤±è´¥';
    } else if (error.message.includes('Failed to fetch')) {
      errorMessage = 'âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
    }
    
    this.contentEl.innerHTML = `
      <div class="error">
        ${errorMessage}
        <br><br>
        <details>
          <summary>é”™è¯¯è¯¦æƒ…</summary>
          <pre>${error.message}</pre>
        </details>
      </div>
    `;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  try {
    new StarField();
    new ContentLoader();
  } catch (error) {
    console.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
  }
});
</script>
</body>
</html>
